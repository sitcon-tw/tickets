---
import Layout from "@layouts/Layout.astro";
import AdminNav from "@components/AdminNav.astro";
import * as i18n from "src/i18n";
import "src/styles/admin.css";
const lang = i18n.local(Astro.url.pathname);
const t = i18n.t(lang, {
	title: {
		"zh-Hant": "ç·¨è¼¯è¡¨å–®",
		"zh-Hans": "ç¼–è¾‘è¡¨å•",
		en: "Edit Form"
	},
	description: {
		"zh-Hant": "åœ¨æ­¤ç·¨è¼¯å ±åè¡¨å–®çš„å•é¡Œèˆ‡çµæ§‹ã€‚",
		"zh-Hans": "åœ¨æ­¤ç¼–è¾‘æŠ¥åè¡¨å•çš„é—®é¢˜ä¸ç»“æ„ã€‚",
		en: "Edit the questions and structure of the registration form here."
	},
	addQuestion: {
		"zh-Hant": "æ–°å¢å•é¡Œ",
		"zh-Hans": "æ–°å¢é—®é¢˜",
		en: "Add Question"
	},
	save: {
		"zh-Hant": "å„²å­˜è¡¨å–®",
		"zh-Hans": "ä¿å­˜è¡¨å•",
		en: "Save Form"
	}
});
const tt = i18n.t(lang, {
	title: {
		"zh-Hant": "ç·¨è¼¯è¡¨å–®",
		"zh-Hans": "ç¼–è¾‘è¡¨å•",
		en: "Edit Form"
	},
});
const l = i18n.l(Astro.url);
---

<Layout i18n={t.t} path="" title={t.title} lang={lang}>
	<AdminNav />
	<main >
		<h1>{t.title}</h1>
		<div id="form-editor" class="editor">
			<div id="questions" class="questions"></div>
			<div class="toolbar">
				<button id="add-question" type="button">+ {t.addQuestion}</button>
				<button id="save-form" type="button" class="primary">ğŸ’¾ {t.save}</button>
			</div>
			<pre id="output" class="output" aria-live="polite"></pre>
		</div>
	</main>

	<style is:global>
		.editor {
			max-width: 960px;
			margin: 1rem auto 4rem;
		}
		.questions {
			display: flex;
			flex-direction: column;
			gap: 12px;
			margin: 1rem 0;
		}
		.question {
			background: #1e1e1e;
			border: 1px solid #333;
			border-radius: 8px;
			padding: 12px 14px;
			display: grid;
			grid-template-columns: 32px 1fr auto;
			gap: 12px;
			align-items: start;
			position: relative;
			will-change: transform, opacity;
		}
		.question.dragging {
			opacity: 0.4;
		}
		.handle {
			cursor: grab;
			user-select: none;
			font-size: 1.1rem;
			line-height: 1;
			display: flex;
			align-items: center;
			justify-content: center;
			color: #999;
		}
		.handle:active {
			cursor: grabbing;
		}
		.q-body {
			display: flex;
			flex-direction: column;
			gap: 6px;
		}
		.q-row {
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
			align-items: center;
		}
		.q-row label {
			font-size: 0.65rem;
			text-transform: uppercase;
			letter-spacing: 0.05em;
			color: #bbb;
		}
		.q-row input[type="text"],
		.q-row select,
		.q-row textarea {
			background: #111;
			border: 1px solid #333;
			color: #eee;
			border-radius: 6px;
			padding: 6px 8px;
			font-size: 0.8rem;
			min-width: 160px;
		}
		.q-row textarea {
			min-height: 60px;
			resize: vertical;
		}
		.type-select {
			width: 140px;
		}
		.options {
			margin-top: 4px;
			padding: 6px 8px;
			border: 1px dashed #444;
			border-radius: 6px;
			background: #161616;
			display: flex;
			flex-direction: column;
			gap: 6px;
		}
		.option-item {
			display: flex;
			gap: 6px;
			align-items: center;
		}
		.option-item.dragging {
			opacity: 0.5;
		}
		.option-item input {
			flex: 1;
		}
		.option-item button {
			background: #222;
			border: 1px solid #444;
			color: #bbb;
			font-size: 0.65rem;
			padding: 4px 6px;
			border-radius: 4px;
		}
		.option-item button:hover {
			background: #333;
			color: #fff;
		}
		.add-option {
			background: #222;
			border: 1px solid #444;
			color: #bbb;
			font-size: 0.65rem;
			padding: 4px 8px;
			border-radius: 4px;
			align-self: flex-start;
		}
		.add-option:hover {
			background: #333;
			color: #fff;
		}
		.delete-question {
			background: #2a0000;
			border: 1px solid #550000;
			color: #ff8d8d;
			font-size: 0.65rem;
			padding: 4px 8px;
			border-radius: 4px;
		}
		.delete-question:hover {
			background: #440000;
			color: #fff;
		}
		.required-toggle {
			display: inline-flex;
			align-items: center;
			gap: 4px;
			font-size: 0.65rem;
			background: #222;
			border: 1px solid #444;
			border-radius: 4px;
			padding: 4px 8px;
			cursor: pointer;
		}
		.required-toggle[data-on="true"] {
			color: #fff;
			border-color: #666;
			background: #303030;
		}
		.toolbar {
			display: flex;
			gap: 12px;
		}
		.output {
			background: #0f0f0f;
			border: 1px solid #222;
			padding: 12px;
			border-radius: 8px;
			max-height: 320px;
			overflow: auto;
			margin-top: 1rem;
			font-size: 0.7rem;
		}
		.empty {
			opacity: 0.6;
			font-style: italic;
			padding: 1rem;
			text-align: center;
			border: 1px dashed #444;
			border-radius: 8px;
		}
	</style>

	<script>
		// @ts-nocheck
		/**
		 * @typedef {Object} ShowIf
		 * @property {string} sourceId - ID of source question whose selection controls visibility
		 * @property {string[]} values - Option values that (if selected) cause the dependent question to show
		 */
		/**
		 * @typedef {Object} Question
		 * @property {string} id
		 * @property {string} label
		 * @property {string} type
		 * @property {boolean} required
		 * @property {string=} help
		 * @property {string[]=} options
		 * @property {ShowIf=} showIf
		 */
		// Fake seed data
		/** @type {Question[]} */
		let questions = [
			{ id: crypto.randomUUID(), label: "å…¨å", type: "text", required: true, help: "è«‹è¼¸å…¥æ‚¨çš„çœŸå¯¦å§“åã€‚" },
			{ id: crypto.randomUUID(), label: "é›»å­éƒµä»¶", type: "email", required: true, help: "è«‹è¼¸å…¥æ‚¨çš„é›»å­éƒµä»¶åœ°å€ã€‚" },
			{ id: crypto.randomUUID(), label: "é›»è©±è™Ÿç¢¼", type: "phone", required: false, help: "è«‹è¼¸å…¥æ‚¨çš„é›»è©±è™Ÿç¢¼ã€‚" },
			{ id: crypto.randomUUID(), label: "Tæ¤å°ºå¯¸", type: "select", required: true, options: ["XS", "S", "M", "L", "XL"], help: "è«‹é¸æ“‡æ‚¨çš„Tæ¤å°ºå¯¸ã€‚" },
			{ id: crypto.randomUUID(), label: "é£²é£Ÿåå¥½", type: "radio", required: false, options: ["ç„¡", "ç´ ", "æ¸…è’¸", "è›‹å¥¶ç´ "], help: "è«‹é¸æ“‡æ‚¨çš„é£²é£Ÿåå¥½ã€‚" },
			{ id: crypto.randomUUID(), label: "æŠ€èƒ½", type: "checkbox", required: false, options: ["Frontend", "Backend", "Design", "DevOps"], help: "è«‹é¸æ“‡æ‚¨çš„æŠ€èƒ½ã€‚" },
			{ id: crypto.randomUUID(), label: "é—œæ–¼ä½ ", type: "textarea", required: false, help: "è«‹ç°¡è¦ä»‹ç´¹è‡ªå·±ã€‚" }
		];

		// Utility: remove any showIf referencing a removed / invalid question
		function purgeInvalidShowIf() {
			const validIds = new Set(questions.map(q => q.id));
			for (const q of questions) {
				const qq = /** @type {any} */ (q);
				if (qq.showIf && !validIds.has(qq.showIf.sourceId)) {
					delete qq.showIf;
					continue;
				}
				if (qq.showIf) {
					const src = questions.find(x => x.id === qq.showIf.sourceId);
					if (!src || !src.options) {
						delete qq.showIf;
						continue;
					}
					qq.showIf.values = qq.showIf.values.filter(v => src.options.includes(v));
					if (!qq.showIf.values.length) delete qq.showIf; // empty condition meaningless
				}
			}
		}

		const questionsEl = document.getElementById("questions");
		const outputEl = document.getElementById("output");
		const addBtn = document.getElementById("add-question");
		const saveBtn = document.getElementById("save-form");

		function render() {
			questionsEl.innerHTML = "";
			if (!questions.length) {
				const empty = document.createElement("div");
				empty.className = "empty";
				empty.textContent = "å°šç„¡å•é¡Œ";
				questionsEl.appendChild(empty);
				return;
			}
			questions.forEach((q, index) => {
				questionsEl.appendChild(renderQuestion(q, index));
			});
		}

		function renderQuestion(q, index) {
			const el = document.createElement("div");
			el.className = "question";
			// We'll manage dragging manually from the handle to avoid conflicts with inner draggables
			el.draggable = false;
			el.dataset.id = q.id;
			el.innerHTML = `
				<div class="handle" title="Drag to reorder" aria-label="Drag">â˜°</div>
				<div class="q-body">
					<div class="q-row">
						<label>å•é¡Œ</label>
						<input type="text" value="${q.label ?? ""}" placeholder="å•é¡Œæ¨™ç±¤" data-field="label" />
						<label>ç¨®é¡</label>
						<select class="type-select" data-field="type">${["text", "email", "phone", "textarea", "select", "radio", "checkbox"].map(t => `<option value="${t}" ${q.type === t ? "selected" : ""}>${t}</option>`).join("")}</select>
						<button type="button" class="required-toggle" data-field="required" data-on="${q.required ? "true" : "false"}">${q.required ? "å¿…å¡«" : "é¸å¡«"}</button>
						<button type="button" class="delete-question" title="Delete">âœ•</button>
					</div>
					<div class="q-row">
						<label>èªªæ˜</label>
						<input type="text" value="${q.help ?? ""}" placeholder="èªªæ˜æ–‡å­— (é¸å¡«)" data-field="help" />
					</div>
					<div class="q-row visibility" data-role="visibility-row">
						<label>å¯è¦‹æ€§</label>
						<select data-role="vis-mode">
							<option value="always" ${q.showIf ? "" : "selected"}>ç¸½æ˜¯</option>
							<option value="conditional" ${q.showIf ? "selected" : ""}>æ¢ä»¶å¼</option>
						</select>
						<select data-role="vis-source" style="display:${q.showIf ? "inline-block" : "none"}"></select>
						<span data-role="vis-values" style="display:${q.showIf ? "inline-flex" : "none"};gap:4px;flex-wrap:wrap;"></span>
						${q.showIf ? `<span class="cond-badge" title="Condition: depends on another question" style="background:#262626;border:1px solid #444;padding:2px 6px;border-radius:4px;font-size:0.55rem;letter-spacing:.05em;">IF</span>` : ""}
					</div>
					<div class="options-wrapper"></div>
				</div>
			`;

			const optWrapper = el.querySelector(".options-wrapper");
			function renderOptions() {
				const needs = ["select", "radio", "checkbox"].includes(q.type);
				optWrapper.innerHTML = "";
				if (!needs) return;
				if (!q.options) q.options = [];
				const box = document.createElement("div");
				box.className = "options";
				q.options.forEach((opt, i) => {
					const row = document.createElement("div");
					row.className = "option-item";
					row.draggable = true; // make option items draggable
					row.dataset.index = String(i);
					row.innerHTML = `<span style="cursor:grab" title="Drag option" data-role="opthandle">â‹®â‹®</span><input type="text" value="${opt}" data-idx="${i}" /><button type="button" data-role="delopt">åˆªé™¤</button>`;
					box.appendChild(row);
				});
				const addOpt = document.createElement("button");
				addOpt.type = "button";
				addOpt.className = "add-option";
				addOpt.textContent = "+ æ–°å¢é¸é …";
				addOpt.addEventListener("click", () => {
					q.options.push("");
					renderOptions();
				});
				box.appendChild(addOpt);
				optWrapper.appendChild(box);

				// Option events
				box.addEventListener("input", e => {
					const target = e.target as HTMLElement;
					if (target && target.matches("input[data-idx]")) {
						const input = target as HTMLInputElement;
						const i = +(input.dataset.idx || "0");
						q.options[i] = input.value;
					}
				});
				box.addEventListener("click", e => {
					const target = e.target as HTMLElement;
					if (target && target.matches("button[data-role=delopt]")) {
						const row = target.closest(".option-item");
						const idx = [...row.parentNode.children].indexOf(row);
						q.options.splice(idx, 1);
						renderOptions();
					}
				});

				// Drag & drop for option reordering
				function getOptionAfterElement(container, y) {
					const els = [...container.querySelectorAll(".option-item:not(.dragging)")];
					return els.reduce(
						(closest, child) => {
							const box = child.getBoundingClientRect();
							const offset = y - box.top - box.height / 2;
							if (offset < 0 && offset > closest.offset) {
								return { offset, element: child };
							} else {
								return closest;
							}
						},
						{ offset: Number.NEGATIVE_INFINITY }
					).element;
				}

				let optDragScheduled = false;
				box.addEventListener("dragstart", e => {
					const row = (e.target as HTMLElement).closest(".option-item");
					if (!row) return;
					// Prevent bubbling so parent question drag handler doesn't trigger
					e.stopPropagation();
					// Prevent starting drag when interacting with input (unless handle used)
					if ((e.target as HTMLElement).tagName === "INPUT" && !(e.target as HTMLElement).dataset.role) {
						e.preventDefault();
						return;
					}
					row.classList.add("dragging");
					(e.dataTransfer || (e as DragEvent).dataTransfer).effectAllowed = "move";
				});
				box.addEventListener("dragend", e => {
					const row = (e.target as HTMLElement).closest(".option-item");
					if (row) row.classList.remove("dragging");
					// Ensure parent question not left in dragging state accidentally
					const parentQ = (e.target as HTMLElement).closest(".question.dragging");
					if (parentQ) parentQ.classList.remove("dragging");
				});
				box.addEventListener("dragover", e => {
					if (!box.querySelector(".option-item.dragging")) return;
					e.preventDefault();
					if (optDragScheduled) return;
					optDragScheduled = true;
					requestAnimationFrame(() => {
						optDragScheduled = false;
						const after = getOptionAfterElement(box, e.clientY);
						const dragging = box.querySelector(".option-item.dragging");
						if (!dragging) return;
						const addBtnEl = box.querySelector(".add-option");
						if (after == null) {
							// insert before the add button
							if (addBtnEl) box.insertBefore(dragging, addBtnEl);
						} else if (after !== dragging) {
							box.insertBefore(dragging, after);
						}
					});
				});
				box.addEventListener("drop", e => {
					e.preventDefault();
					const orderEls = [...box.querySelectorAll(".option-item")];
					// Build new ordered array based on original indices stored in dataset.index
					const reordered = orderEls.map(r => q.options[+(r as HTMLElement).dataset.index]);
					q.options = reordered;
					// Re-render to refresh indices
					renderOptions();
					// Update any questions whose showIf references this question so values stay valid
					purgeInvalidShowIf();
				});
			}
			renderOptions();

			// Visibility condition UI wiring
			(function setupVisibility() {
				const modeSel = el.querySelector("[data-role=vis-mode]") as HTMLSelectElement;
				const srcSel = el.querySelector("[data-role=vis-source]") as HTMLSelectElement;
				const valBox = el.querySelector("[data-role=vis-values]") as HTMLElement;

				function populateSources() {
					srcSel.innerHTML =
						'<option value="">-- Select question --</option>' +
						questions
							.filter(x => x.id !== q.id && x.options && ["select", "radio", "checkbox"].includes(x.type))
							.map(x => `<option value="${x.id}" ${q.showIf && q.showIf.sourceId === x.id ? "selected" : ""}>${x.label || "(Untitled)"} (${x.type})</option>`)
							.join("");
				}

				function populateValues() {
					valBox.innerHTML = "";
					if (!q.showIf) return;
					const src = questions.find(x => x.id === q.showIf.sourceId);
					if (!src || !src.options) return;
					src.options.forEach(opt => {
						const id = "chk_" + q.id + "_" + btoa(opt).replace(/[^a-z0-9]/gi, "");
						const wrap = document.createElement("label");
						wrap.style.fontSize = "0.6rem";
						wrap.style.background = "#1c1c1c";
						wrap.style.padding = "2px 4px";
						wrap.style.borderRadius = "4px";
						wrap.style.border = "1px solid #333";
						wrap.innerHTML = `<input type="checkbox" data-role="vis-val" value="${opt.replace(/"/g, "&quot;")}" ${q.showIf.values.includes(opt) ? "checked" : ""}/> ${opt}`;
						valBox.appendChild(wrap);
					});
				}

				populateSources();
				if (q.showIf) populateValues();

				modeSel?.addEventListener("change", () => {
					if (modeSel.value === "conditional") {
						q.showIf = { sourceId: "", values: [] };
						srcSel.style.display = "inline-block";
						valBox.style.display = "inline-flex";
						populateSources();
						populateValues();
					} else {
						delete q.showIf;
						srcSel.style.display = "none";
						valBox.style.display = "none";
					}
				});

				srcSel?.addEventListener("change", () => {
					if (!q.showIf) return; // safety
					q.showIf.sourceId = srcSel.value;
					q.showIf.values = [];
					populateValues();
				});

				valBox?.addEventListener("change", e => {
					const target = e.target as HTMLInputElement;
					if (!target || target.dataset.role !== "vis-val" || !q.showIf) return;
					if (target.checked) {
						if (!q.showIf.values.includes(target.value)) q.showIf.values.push(target.value);
					} else {
						q.showIf.values = q.showIf.values.filter(v => v !== target.value);
					}
					if (!q.showIf.values.length) delete q.showIf; // auto remove empty
				});
			})();

			// Field changes
			el.addEventListener("input", e => {
				const target = e.target as HTMLElement;
				if (!target) return;
				const field = (target as any).dataset?.field;
				if (!field) return;
				q[field] = (target as HTMLInputElement).value;
				if (field === "type") {
					// reset options if type changed
					if (!["select", "radio", "checkbox"].includes(q.type)) delete q.options;
					// If this question turns into non-options type, purge dependents referencing it
					purgeInvalidShowIf();
					renderOptions();
				}
			});
			el.addEventListener("click", e => {
				const target = e.target as HTMLElement;
				if (!target) return;
				if (target.classList.contains("required-toggle")) {
					q.required = !q.required;
					target.dataset.on = q.required ? "true" : "false";
					target.textContent = q.required ? "å¿…å¡« Required" : "é¸å¡« Optional";
				}
				if (target.classList.contains("delete-question")) {
					questions = questions.filter(x => x.id !== q.id);
					purgeInvalidShowIf();
					render();
				}
			});

			// Drag hooks (question reorder) - attach to handle only
			const handle = el.querySelector(".handle") as HTMLElement;
			if (handle) {
				handle.draggable = true;
				handle.addEventListener("dragstart", e => {
					// start dragging the question element
					el.classList.add("dragging");
					(e.dataTransfer || (e as DragEvent).dataTransfer).effectAllowed = "move";
					(e.dataTransfer || (e as DragEvent).dataTransfer).setData("text/plain", q.id);
				});
				handle.addEventListener("dragend", () => el.classList.remove("dragging"));
			}

			return el;
		}

		function getDragAfterElement(container, y) {
			const els = [...container.querySelectorAll(".question:not(.dragging)")];
			return els.reduce(
				(closest, child) => {
					const box = child.getBoundingClientRect();
					const offset = y - box.top - box.height / 2;
					if (offset < 0 && offset > closest.offset) {
						return { offset, element: child };
					} else {
						return closest;
					}
				},
				{ offset: Number.NEGATIVE_INFINITY }
			).element;
		}

		// Single container-level dragover/drop to avoid N listeners & thrash
		let dragOverScheduled = false;
		questionsEl.addEventListener("dragover", e => {
			if (!document.querySelector(".question.dragging")) return; // no active drag
			e.preventDefault();
			if (dragOverScheduled) return;
			dragOverScheduled = true;
			requestAnimationFrame(() => {
				dragOverScheduled = false;
				const after = getDragAfterElement(questionsEl, e.clientY);
				const dragging = document.querySelector(".question.dragging");
				if (!dragging) return;
				if (after == null) {
					questionsEl.appendChild(dragging);
				} else if (after !== dragging) {
					questionsEl.insertBefore(dragging, after);
				}
			});
		});
		questionsEl.addEventListener("drop", e => {
			e.preventDefault();
			// Update underlying array based on current DOM order (no full re-render needed)
			const ids = [...questionsEl.querySelectorAll(".question")].map(n => (n as HTMLElement).dataset.id);
			questions.sort((a, b) => ids.indexOf(a.id) - ids.indexOf(b.id));
			// Optionally, could update preview/output if open; do nothing else for perf.
		});

		addBtn.addEventListener("click", () => {
			questions.push({ id: crypto.randomUUID(), label: "æ–°å•é¡Œ", type: "text", required: false });
			render();
		});

		saveBtn.addEventListener("click", () => {
			const data = JSON.stringify(questions, null, 2);
			outputEl.textContent = data;
			console.log("[FormEditor] Saved questions", questions);
		});

		render();
	</script>
</Layout>
