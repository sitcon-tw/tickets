---
import Layout from "@layouts/Layout.astro";
import AdminNav from "@components/AdminNav.astro";
import * as i18n from "src/i18n";
import "src/styles/admin.css";
const lang = i18n.local(Astro.url.pathname);
const t = i18n.t(lang, {
	title: {
		"zh-Hant": "編輯表單",
		"zh-Hans": "编辑表单",
		en: "Edit Form"
	},
	description: {
		"zh-Hant": "在此編輯報名表單的問題與結構。",
		"zh-Hans": "在此编辑报名表单的问题与结构。",
		en: "Edit the questions and structure of the registration form here."
	},
	addQuestion: {
		"zh-Hant": "新增問題",
		"zh-Hans": "新增问题",
		en: "Add Question"
	},
	save: {
		"zh-Hant": "儲存表單",
		"zh-Hans": "保存表单",
		en: "Save Form"
	}
});
const tt = i18n.t(lang, {
	title: {
		"zh-Hant": "編輯表單",
		"zh-Hans": "编辑表单",
		en: "Edit Form"
	},
});
const l = i18n.l(Astro.url);
---

<Layout i18n={t.t} path="" title={t.title} lang={lang}>
	<AdminNav />
	<main >
		<h1>{t.title}</h1>
		<div id="form-editor" class="editor">
			<div id="questions" class="questions"></div>
			<div class="toolbar">
				<button id="add-question" type="button">+ {t.addQuestion}</button>
				<button id="save-form" type="button" class="primary">💾 {t.save}</button>
			</div>
			<pre id="output" class="output" aria-live="polite"></pre>
		</div>
	</main>

	<style is:global>
		.editor {
			max-width: 960px;
			margin: 1rem auto 4rem;
		}
		.questions {
			display: flex;
			flex-direction: column;
			gap: 12px;
			margin: 1rem 0;
		}
		.question {
			background: #1e1e1e;
			border: 1px solid #333;
			border-radius: 8px;
			padding: 12px 14px;
			display: grid;
			grid-template-columns: 32px 1fr auto;
			gap: 12px;
			align-items: start;
			position: relative;
			will-change: transform, opacity;
		}
		.question.dragging {
			opacity: 0.4;
		}
		.handle {
			cursor: grab;
			user-select: none;
			font-size: 1.1rem;
			line-height: 1;
			display: flex;
			align-items: center;
			justify-content: center;
			color: #999;
		}
		.handle:active {
			cursor: grabbing;
		}
		.q-body {
			display: flex;
			flex-direction: column;
			gap: 6px;
		}
		.q-row {
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
			align-items: center;
		}
		.q-row label {
			font-size: 0.65rem;
			text-transform: uppercase;
			letter-spacing: 0.05em;
			color: #bbb;
		}
		.q-row input[type="text"],
		.q-row select,
		.q-row textarea {
			background: #111;
			border: 1px solid #333;
			color: #eee;
			border-radius: 6px;
			padding: 6px 8px;
			font-size: 0.8rem;
			min-width: 160px;
		}
		.q-row textarea {
			min-height: 60px;
			resize: vertical;
		}
		.type-select {
			width: 140px;
		}
		.options {
			margin-top: 4px;
			padding: 6px 8px;
			border: 1px dashed #444;
			border-radius: 6px;
			background: #161616;
			display: flex;
			flex-direction: column;
			gap: 6px;
		}
		.option-item {
			display: flex;
			gap: 6px;
			align-items: center;
		}
		.option-item.dragging {
			opacity: 0.5;
		}
		.option-item input {
			flex: 1;
		}
		.option-item button {
			background: #222;
			border: 1px solid #444;
			color: #bbb;
			font-size: 0.65rem;
			padding: 4px 6px;
			border-radius: 4px;
		}
		.option-item button:hover {
			background: #333;
			color: #fff;
		}
		.add-option {
			background: #222;
			border: 1px solid #444;
			color: #bbb;
			font-size: 0.65rem;
			padding: 4px 8px;
			border-radius: 4px;
			align-self: flex-start;
		}
		.add-option:hover {
			background: #333;
			color: #fff;
		}
		.delete-question {
			background: #2a0000;
			border: 1px solid #550000;
			color: #ff8d8d;
			font-size: 0.65rem;
			padding: 4px 8px;
			border-radius: 4px;
		}
		.delete-question:hover {
			background: #440000;
			color: #fff;
		}
		.required-toggle {
			display: inline-flex;
			align-items: center;
			gap: 4px;
			font-size: 0.65rem;
			background: #222;
			border: 1px solid #444;
			border-radius: 4px;
			padding: 4px 8px;
			cursor: pointer;
		}
		.required-toggle[data-on="true"] {
			color: #fff;
			border-color: #666;
			background: #303030;
		}
		.toolbar {
			display: flex;
			gap: 12px;
		}
		.output {
			background: #0f0f0f;
			border: 1px solid #222;
			padding: 12px;
			border-radius: 8px;
			max-height: 320px;
			overflow: auto;
			margin-top: 1rem;
			font-size: 0.7rem;
		}
		.empty {
			opacity: 0.6;
			font-style: italic;
			padding: 1rem;
			text-align: center;
			border: 1px dashed #444;
			border-radius: 8px;
		}
	</style>

	<script>
		// @ts-nocheck
		import { formFields as formFieldsAPI, events as eventsAPI, tickets as ticketsAPI, initializeAdminPage } from "../../lib/admin.js";

		/**
		 * @typedef {Object} ShowIf
		 * @property {string} sourceId - ID of source question whose selection controls visibility
		 * @property {string[]} values - Option values that (if selected) cause the dependent question to show
		 */
		/**
		 * @typedef {Object} Question
		 * @property {string} id
		 * @property {string} label
		 * @property {string} type
		 * @property {boolean} required
		 * @property {string=} help
		 * @property {string[]=} options
		 * @property {ShowIf=} showIf
		 */

		// Global state
		let currentEventId = null;
		let currentTicketId = null;
		let questions = [];
		let isLoading = false;

		// Initialize page
		async function initializePage() {
			try {
				// Check admin authentication
				const isAuthorized = await initializeAdminPage();
				if (!isAuthorized) return;

				// Load events and tickets to get form fields
				await loadEventAndTicket();
				
				if (currentTicketId) {
					await loadFormFields();
				} else {
					// Fall back to demo data if no ticket found
					loadDemoData();
				}
				
				// Setup event listeners
				setupEventListeners();
				
				// Initial render
				render();
				
			} catch (error) {
				console.error('Failed to initialize forms page:', error);
				showError('Failed to load page. Please try refreshing.');
				// Fall back to demo data
				loadDemoData();
				render();
			}
		}

		// Load event and ticket data
		async function loadEventAndTicket() {
			try {
				// Get first active event
				const eventsResponse = await eventsAPI.list();
				if (eventsResponse.success && eventsResponse.data && eventsResponse.data.length > 0) {
					currentEventId = eventsResponse.data[0].id;
					
					// Get first ticket of the event
					const ticketsResponse = await ticketsAPI.list(currentEventId);
					if (ticketsResponse.success && ticketsResponse.data && ticketsResponse.data.length > 0) {
						currentTicketId = ticketsResponse.data[0].id;
					}
				}
			} catch (error) {
				console.error('Failed to load event and ticket:', error);
				throw error;
			}
		}

		// Load form fields from backend
		async function loadFormFields() {
			if (isLoading || !currentTicketId) return;
			
			isLoading = true;
			showLoading(true);
			
			try {
				const response = await formFieldsAPI.list(currentTicketId);
				
				if (response.success) {
					// Convert backend form fields to frontend question format
					questions = (response.data || []).map(field => ({
						id: field.id,
						label: field.description || field.name,
						type: field.type,
						required: field.required || false,
						help: field.helpText || '',
						options: field.values ? JSON.parse(field.values) : undefined
					}));
				} else {
					throw new Error(response.message || 'Failed to load form fields');
				}
			} catch (error) {
				console.error('Failed to load form fields:', error);
				showError('Failed to load form fields: ' + error.message);
				// Fall back to demo data
				loadDemoData();
			} finally {
				isLoading = false;
				showLoading(false);
			}
		}

		// Load demo data (fallback)
		function loadDemoData() {
			questions = [
				{ id: crypto.randomUUID(), label: "全名", type: "text", required: true, help: "請輸入您的真實姓名。" },
				{ id: crypto.randomUUID(), label: "電子郵件", type: "email", required: true, help: "請輸入您的電子郵件地址。" },
				{ id: crypto.randomUUID(), label: "電話號碼", type: "phone", required: false, help: "請輸入您的電話號碼。" },
				{ id: crypto.randomUUID(), label: "T恤尺寸", type: "select", required: true, options: ["XS", "S", "M", "L", "XL"], help: "請選擇您的T恤尺寸。" },
				{ id: crypto.randomUUID(), label: "飲食偏好", type: "radio", required: false, options: ["無", "素", "清蒸", "蛋奶素"], help: "請選擇您的飲食偏好。" },
				{ id: crypto.randomUUID(), label: "技能", type: "checkbox", required: false, options: ["Frontend", "Backend", "Design", "DevOps"], help: "請選擇您的技能。" },
				{ id: crypto.randomUUID(), label: "關於你", type: "textarea", required: false, help: "請簡要介紹自己。" }
			];
		}

		// Setup event listeners
		function setupEventListeners() {
			const addBtn = document.getElementById("add-question");
			const saveBtn = document.getElementById("save-form");
			
			if (addBtn) {
				addBtn.addEventListener("click", addQuestion);
			}
			
			if (saveBtn) {
				saveBtn.addEventListener("click", saveForm);
			}
		}

		// Save form to backend
		async function saveForm() {
			if (!currentTicketId) {
				alert('無法保存：未找到票種');
				return;
			}

			try {
				saveBtn.disabled = true;
				saveBtn.textContent = '保存中...';

				// Convert questions to backend format
				const formFieldsData = questions.map((q, index) => ({
					id: q.id.startsWith('temp-') ? undefined : q.id, // Don't send temp IDs
					name: q.label.toLowerCase().replace(/\s+/g, '_'),
					description: q.label,
					type: q.type,
					required: q.required,
					helpText: q.help,
					values: q.options ? JSON.stringify(q.options) : null,
					order: index
				}));

				// This is a simplified save - in reality, you'd need to handle
				// create vs update operations for each field
				for (const fieldData of formFieldsData) {
					// Add ticketId to the field data
					fieldData.ticketId = currentTicketId;
					
					if (fieldData.id) {
						// Update existing field
						await formFieldsAPI.update(fieldData.id, fieldData);
					} else {
						// Create new field
						await formFieldsAPI.create(fieldData);
					}
				}

				alert('表單已保存！');
			} catch (error) {
				console.error('Failed to save form:', error);
				alert('保存失敗: ' + error.message);
			} finally {
				saveBtn.disabled = false;
				saveBtn.textContent = '💾 保存表單';
			}
		}

		// UI utility functions
		function showLoading(show) {
			// Add loading indicator if needed
		}

		function showError(message) {
			console.error(message);
			// Could add error display UI here
		}

		// Fake seed data (fallback)
		/** @type {Question[]} */

		// Utility: remove any showIf referencing a removed / invalid question
		function purgeInvalidShowIf() {
			const validIds = new Set(questions.map(q => q.id));
			for (const q of questions) {
				const qq = /** @type {any} */ (q);
				if (qq.showIf && !validIds.has(qq.showIf.sourceId)) {
					delete qq.showIf;
					continue;
				}
				if (qq.showIf) {
					const src = questions.find(x => x.id === qq.showIf.sourceId);
					if (!src || !src.options) {
						delete qq.showIf;
						continue;
					}
					qq.showIf.values = qq.showIf.values.filter(v => src.options.includes(v));
					if (!qq.showIf.values.length) delete qq.showIf; // empty condition meaningless
				}
			}
		}

		const questionsEl = document.getElementById("questions");
		const outputEl = document.getElementById("output");
		const addBtn = document.getElementById("add-question");
		const saveBtn = document.getElementById("save-form");

		function render() {
			questionsEl.innerHTML = "";
			if (!questions.length) {
				const empty = document.createElement("div");
				empty.className = "empty";
				empty.textContent = "尚無問題";
				questionsEl.appendChild(empty);
				return;
			}
			questions.forEach((q, index) => {
				questionsEl.appendChild(renderQuestion(q, index));
			});
		}

		function renderQuestion(q, index) {
			const el = document.createElement("div");
			el.className = "question";
			// We'll manage dragging manually from the handle to avoid conflicts with inner draggables
			el.draggable = false;
			el.dataset.id = q.id;
			el.innerHTML = `
				<div class="handle" title="Drag to reorder" aria-label="Drag">☰</div>
				<div class="q-body">
					<div class="q-row">
						<label>問題</label>
						<input type="text" value="${q.label ?? ""}" placeholder="問題標籤" data-field="label" />
						<label>種類</label>
						<select class="type-select" data-field="type">${["text", "email", "phone", "textarea", "select", "radio", "checkbox"].map(t => `<option value="${t}" ${q.type === t ? "selected" : ""}>${t}</option>`).join("")}</select>
						<button type="button" class="required-toggle" data-field="required" data-on="${q.required ? "true" : "false"}">${q.required ? "必填" : "選填"}</button>
						<button type="button" class="delete-question" title="Delete">✕</button>
					</div>
					<div class="q-row">
						<label>說明</label>
						<input type="text" value="${q.help ?? ""}" placeholder="說明文字 (選填)" data-field="help" />
					</div>
					<div class="q-row visibility" data-role="visibility-row">
						<label>可見性</label>
						<select data-role="vis-mode">
							<option value="always" ${q.showIf ? "" : "selected"}>總是</option>
							<option value="conditional" ${q.showIf ? "selected" : ""}>條件式</option>
						</select>
						<select data-role="vis-source" style="display:${q.showIf ? "inline-block" : "none"}"></select>
						<span data-role="vis-values" style="display:${q.showIf ? "inline-flex" : "none"};gap:4px;flex-wrap:wrap;"></span>
						${q.showIf ? `<span class="cond-badge" title="Condition: depends on another question" style="background:#262626;border:1px solid #444;padding:2px 6px;border-radius:4px;font-size:0.55rem;letter-spacing:.05em;">IF</span>` : ""}
					</div>
					<div class="options-wrapper"></div>
				</div>
			`;

			const optWrapper = el.querySelector(".options-wrapper");
			function renderOptions() {
				const needs = ["select", "radio", "checkbox"].includes(q.type);
				optWrapper.innerHTML = "";
				if (!needs) return;
				if (!q.options) q.options = [];
				const box = document.createElement("div");
				box.className = "options";
				q.options.forEach((opt, i) => {
					const row = document.createElement("div");
					row.className = "option-item";
					row.draggable = true; // make option items draggable
					row.dataset.index = String(i);
					row.innerHTML = `<span style="cursor:grab" title="Drag option" data-role="opthandle">⋮⋮</span><input type="text" value="${opt}" data-idx="${i}" /><button type="button" data-role="delopt">刪除</button>`;
					box.appendChild(row);
				});
				const addOpt = document.createElement("button");
				addOpt.type = "button";
				addOpt.className = "add-option";
				addOpt.textContent = "+ 新增選項";
				addOpt.addEventListener("click", () => {
					q.options.push("");
					renderOptions();
				});
				box.appendChild(addOpt);
				optWrapper.appendChild(box);

				// Option events
				box.addEventListener("input", e => {
					const target = e.target as HTMLElement;
					if (target && target.matches("input[data-idx]")) {
						const input = target as HTMLInputElement;
						const i = +(input.dataset.idx || "0");
						q.options[i] = input.value;
					}
				});
				box.addEventListener("click", e => {
					const target = e.target as HTMLElement;
					if (target && target.matches("button[data-role=delopt]")) {
						const row = target.closest(".option-item");
						const idx = [...row.parentNode.children].indexOf(row);
						q.options.splice(idx, 1);
						renderOptions();
					}
				});

				// Drag & drop for option reordering
				function getOptionAfterElement(container, y) {
					const els = [...container.querySelectorAll(".option-item:not(.dragging)")];
					return els.reduce(
						(closest, child) => {
							const box = child.getBoundingClientRect();
							const offset = y - box.top - box.height / 2;
							if (offset < 0 && offset > closest.offset) {
								return { offset, element: child };
							} else {
								return closest;
							}
						},
						{ offset: Number.NEGATIVE_INFINITY }
					).element;
				}

				let optDragScheduled = false;
				box.addEventListener("dragstart", e => {
					const row = (e.target as HTMLElement).closest(".option-item");
					if (!row) return;
					// Prevent bubbling so parent question drag handler doesn't trigger
					e.stopPropagation();
					// Prevent starting drag when interacting with input (unless handle used)
					if ((e.target as HTMLElement).tagName === "INPUT" && !(e.target as HTMLElement).dataset.role) {
						e.preventDefault();
						return;
					}
					row.classList.add("dragging");
					(e.dataTransfer || (e as DragEvent).dataTransfer).effectAllowed = "move";
				});
				box.addEventListener("dragend", e => {
					const row = (e.target as HTMLElement).closest(".option-item");
					if (row) row.classList.remove("dragging");
					// Ensure parent question not left in dragging state accidentally
					const parentQ = (e.target as HTMLElement).closest(".question.dragging");
					if (parentQ) parentQ.classList.remove("dragging");
				});
				box.addEventListener("dragover", e => {
					if (!box.querySelector(".option-item.dragging")) return;
					e.preventDefault();
					if (optDragScheduled) return;
					optDragScheduled = true;
					requestAnimationFrame(() => {
						optDragScheduled = false;
						const after = getOptionAfterElement(box, e.clientY);
						const dragging = box.querySelector(".option-item.dragging");
						if (!dragging) return;
						const addBtnEl = box.querySelector(".add-option");
						if (after == null) {
							// insert before the add button
							if (addBtnEl) box.insertBefore(dragging, addBtnEl);
						} else if (after !== dragging) {
							box.insertBefore(dragging, after);
						}
					});
				});
				box.addEventListener("drop", e => {
					e.preventDefault();
					const orderEls = [...box.querySelectorAll(".option-item")];
					// Build new ordered array based on original indices stored in dataset.index
					const reordered = orderEls.map(r => q.options[+(r as HTMLElement).dataset.index]);
					q.options = reordered;
					// Re-render to refresh indices
					renderOptions();
					// Update any questions whose showIf references this question so values stay valid
					purgeInvalidShowIf();
				});
			}
			renderOptions();

			// Visibility condition UI wiring
			(function setupVisibility() {
				const modeSel = el.querySelector("[data-role=vis-mode]") as HTMLSelectElement;
				const srcSel = el.querySelector("[data-role=vis-source]") as HTMLSelectElement;
				const valBox = el.querySelector("[data-role=vis-values]") as HTMLElement;

				function populateSources() {
					srcSel.innerHTML =
						'<option value="">-- Select question --</option>' +
						questions
							.filter(x => x.id !== q.id && x.options && ["select", "radio", "checkbox"].includes(x.type))
							.map(x => `<option value="${x.id}" ${q.showIf && q.showIf.sourceId === x.id ? "selected" : ""}>${x.label || "(Untitled)"} (${x.type})</option>`)
							.join("");
				}

				function populateValues() {
					valBox.innerHTML = "";
					if (!q.showIf) return;
					const src = questions.find(x => x.id === q.showIf.sourceId);
					if (!src || !src.options) return;
					src.options.forEach(opt => {
						const id = "chk_" + q.id + "_" + btoa(opt).replace(/[^a-z0-9]/gi, "");
						const wrap = document.createElement("label");
						wrap.style.fontSize = "0.6rem";
						wrap.style.background = "#1c1c1c";
						wrap.style.padding = "2px 4px";
						wrap.style.borderRadius = "4px";
						wrap.style.border = "1px solid #333";
						wrap.innerHTML = `<input type="checkbox" data-role="vis-val" value="${opt.replace(/"/g, "&quot;")}" ${q.showIf.values.includes(opt) ? "checked" : ""}/> ${opt}`;
						valBox.appendChild(wrap);
					});
				}

				populateSources();
				if (q.showIf) populateValues();

				modeSel?.addEventListener("change", () => {
					if (modeSel.value === "conditional") {
						q.showIf = { sourceId: "", values: [] };
						srcSel.style.display = "inline-block";
						valBox.style.display = "inline-flex";
						populateSources();
						populateValues();
					} else {
						delete q.showIf;
						srcSel.style.display = "none";
						valBox.style.display = "none";
					}
				});

				srcSel?.addEventListener("change", () => {
					if (!q.showIf) return; // safety
					q.showIf.sourceId = srcSel.value;
					q.showIf.values = [];
					populateValues();
				});

				valBox?.addEventListener("change", e => {
					const target = e.target as HTMLInputElement;
					if (!target || target.dataset.role !== "vis-val" || !q.showIf) return;
					if (target.checked) {
						if (!q.showIf.values.includes(target.value)) q.showIf.values.push(target.value);
					} else {
						q.showIf.values = q.showIf.values.filter(v => v !== target.value);
					}
					if (!q.showIf.values.length) delete q.showIf; // auto remove empty
				});
			})();

			// Field changes
			el.addEventListener("input", e => {
				const target = e.target as HTMLElement;
				if (!target) return;
				const field = (target as any).dataset?.field;
				if (!field) return;
				q[field] = (target as HTMLInputElement).value;
				if (field === "type") {
					// reset options if type changed
					if (!["select", "radio", "checkbox"].includes(q.type)) delete q.options;
					// If this question turns into non-options type, purge dependents referencing it
					purgeInvalidShowIf();
					renderOptions();
				}
			});
			el.addEventListener("click", e => {
				const target = e.target as HTMLElement;
				if (!target) return;
				if (target.classList.contains("required-toggle")) {
					q.required = !q.required;
					target.dataset.on = q.required ? "true" : "false";
					target.textContent = q.required ? "必填 Required" : "選填 Optional";
				}
				if (target.classList.contains("delete-question")) {
					questions = questions.filter(x => x.id !== q.id);
					purgeInvalidShowIf();
					render();
				}
			});

			// Drag hooks (question reorder) - attach to handle only
			const handle = el.querySelector(".handle") as HTMLElement;
			if (handle) {
				handle.draggable = true;
				handle.addEventListener("dragstart", e => {
					// start dragging the question element
					el.classList.add("dragging");
					(e.dataTransfer || (e as DragEvent).dataTransfer).effectAllowed = "move";
					(e.dataTransfer || (e as DragEvent).dataTransfer).setData("text/plain", q.id);
				});
				handle.addEventListener("dragend", () => el.classList.remove("dragging"));
			}

			return el;
		}

		function getDragAfterElement(container, y) {
			const els = [...container.querySelectorAll(".question:not(.dragging)")];
			return els.reduce(
				(closest, child) => {
					const box = child.getBoundingClientRect();
					const offset = y - box.top - box.height / 2;
					if (offset < 0 && offset > closest.offset) {
						return { offset, element: child };
					} else {
						return closest;
					}
				},
				{ offset: Number.NEGATIVE_INFINITY }
			).element;
		}

		// Single container-level dragover/drop to avoid N listeners & thrash
		let dragOverScheduled = false;
		questionsEl.addEventListener("dragover", e => {
			if (!document.querySelector(".question.dragging")) return; // no active drag
			e.preventDefault();
			if (dragOverScheduled) return;
			dragOverScheduled = true;
			requestAnimationFrame(() => {
				dragOverScheduled = false;
				const after = getDragAfterElement(questionsEl, e.clientY);
				const dragging = document.querySelector(".question.dragging");
				if (!dragging) return;
				if (after == null) {
					questionsEl.appendChild(dragging);
				} else if (after !== dragging) {
					questionsEl.insertBefore(dragging, after);
				}
			});
		});
		questionsEl.addEventListener("drop", e => {
			e.preventDefault();
			// Update underlying array based on current DOM order (no full re-render needed)
			const ids = [...questionsEl.querySelectorAll(".question")].map(n => (n as HTMLElement).dataset.id);
			questions.sort((a, b) => ids.indexOf(a.id) - ids.indexOf(b.id));
			// Optionally, could update preview/output if open; do nothing else for perf.
		});

		// Add question function
		function addQuestion() {
			questions.push({ 
				id: 'temp-' + crypto.randomUUID(), 
				label: "新問題", 
				type: "text", 
				required: false 
			});
			render();
		}

		// Initialize page when DOM is ready
		document.addEventListener('DOMContentLoaded', initializePage);
	</script>
</Layout>
